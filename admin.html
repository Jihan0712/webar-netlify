<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>INRL AR Admin Dashboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside class="w-64 bg-gray-900 text-white flex flex-col p-6">
        <h1 class="text-2xl font-bold mb-8 text-center">INRL AR</h1>
        <nav class="flex flex-col space-y-3">
          <button id="uploadTab" class="py-2 px-3 rounded bg-blue-600 hover:bg-blue-700 text-left">Upload Target</button>
          <button id="listTab" class="py-2 px-3 rounded hover:bg-gray-700 text-left">Existing Targets</button>
        </nav>
        <footer class="mt-auto text-xs text-gray-400 pt-4 border-t border-gray-700">
          &copy; 2025 INRL
        </footer>
      </aside>

      <!-- Main content -->
      <main class="flex-1 p-8">
        <p id="status" class="mb-4 text-sm text-gray-600"></p>

        <!-- Upload Section -->
        <section id="uploadSection">
          <h2 class="text-xl font-semibold mb-4">Upload a New AR Target</h2>
          <div class="bg-white shadow rounded-lg p-6 space-y-4">
            <div>
              <label class="block text-sm font-medium mb-1">Target Name</label>
              <input id="name" type="text" placeholder="Target name"
                class="w-full border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">Marker Image (.jpg/.png)</label>
              <div class="flex gap-2">
                <input id="markerFile" type="file" accept=".jpg,.jpeg,.png" class="flex-1 border p-2 rounded-md" />
                <div class="flex gap-2">
                  <button id="generateMindFile" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition">
                    Generate .mind
                  </button>
                  <button id="serverCompile" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">
                    Compile on Server
                  </button>
                </div>
              </div>
              <p id="compileStatus" class="text-sm text-gray-500 mt-1"></p>
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">.mind File</label>
              <input id="mindFile" type="file" accept=".mind" class="w-full" />
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">.mp4 Video</label>
              <input id="videoFile" type="file" accept="video/mp4" class="w-full" />
            </div>

            <button id="upload" class="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700">
              Upload
            </button>
          </div>
        </section>

        <!-- List Section -->
        <section id="listSection" class="hidden">
          <h2 class="text-xl font-semibold mb-4">Existing Targets</h2>
          <div id="targetsList" class="bg-white shadow rounded-lg overflow-hidden">
            <table class="w-full text-left border-collapse">
              <thead class="bg-gray-200">
                <tr>
                  <th class="p-3">Name</th>
                  <th class="p-3">Created</th>
                  <th class="p-3">Active</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody id="targetsTable"></tbody>
            </table>
          </div>
        </section>
      </main>
    </div>

    <!-- MindAR Compiler Integration -->
    <!-- TensorFlow.js is required by the in-browser compiler. Load it before importing MindAR/Compiler -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js"></script>
    <script type="module">
      // Load Compiler from CDN because local `mind-ar-js/dist` is not present in this repo
      import { Compiler } from 'https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js';

      const SUPABASE_URL = "https://vleqrpqfjkcazeowczjy.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_yB6MBOTVLquZgR4X6yqhTQ_0wBFkhrZ";
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      const uploadBtn = document.getElementById("upload");
      const statusEl = document.getElementById("status");
      const uploadSection = document.getElementById("uploadSection");
      const listSection = document.getElementById("listSection");
      const uploadTab = document.getElementById("uploadTab");
      const listTab = document.getElementById("listTab");
      const targetsTable = document.getElementById("targetsTable");
      const compileStatus = document.getElementById("compileStatus");

      uploadTab.addEventListener("click", () => {
        uploadSection.classList.remove("hidden");
        listSection.classList.add("hidden");
        uploadTab.classList.add("bg-blue-600");
        listTab.classList.remove("bg-blue-600");
      });

      listTab.addEventListener("click", () => {
        listSection.classList.remove("hidden");
        uploadSection.classList.add("hidden");
        listTab.classList.add("bg-blue-600");
        uploadTab.classList.remove("bg-blue-600");
        loadTargets();
      });

      // üß† Generate .mind file from image (client-side)
      document.getElementById("generateMindFile").addEventListener("click", async () => {
        const markerFile = document.getElementById("markerFile").files[0];
        if (!markerFile) {
          compileStatus.textContent = "‚ö†Ô∏è Please select an image file first.";
          return;
        }

        compileStatus.textContent = "üß† Generating .mind file... Please wait.";

        try {
          const img = new Image();
          img.src = URL.createObjectURL(markerFile);
          await img.decode();

          // Some versions expect tf to be available globally; ensure it's loaded
          if (typeof tf === 'undefined') throw new Error('TensorFlow.js (tf) is not loaded. Make sure the tf.min.js script is available.');

          const compiler = new Compiler();
          let result;
          try {
            result = await compiler.compileImageTargets([img]);
          } catch (innerErr) {
            console.error('compileImageTargets error', innerErr);
            throw innerErr;
          }
          const mindData = compiler.exportData ? compiler.exportData() : (result && result.exportData ? result.exportData() : result);

          const blob = new Blob([mindData], { type: "application/octet-stream" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = `${markerFile.name.replace(/\.[^/.]+$/, "")}.mind`;
          a.click();

          compileStatus.textContent = "‚úÖ .mind file generated successfully!";
        } catch (err) {
          console.error(err);
          compileStatus.textContent = "‚ùå Failed to generate .mind file: " + err.message;
        }
      });

      // helper: compile a marker image file in-browser and return an ArrayBuffer
      async function compileImageClient(markerFile, progressCallback) {
        const img = new Image();
        img.src = URL.createObjectURL(markerFile);
        await img.decode();

        if (typeof tf === 'undefined') throw new Error('TensorFlow.js (tf) is not loaded.');

        const compiler = new Compiler();
        // mind-ar's compileImageTargets accepts a progress callback in some variants; we try to pass one
        if (progressCallback) {
          await compiler.compileImageTargets([img], progressCallback);
        } else {
          await compiler.compileImageTargets([img]);
        }
        const buffer = compiler.exportData ? compiler.exportData() : null;
        if (!buffer) throw new Error('Failed to export compiled data');
        return buffer;
      }

      // Server-side compile flow: send image to backend /compile which returns .mind binary
      document.getElementById('serverCompile').addEventListener('click', async () => {
        const markerFile = document.getElementById('markerFile').files[0];
        if (!markerFile) {
          compileStatus.textContent = '‚ö†Ô∏è Please select an image file first.';
          return;
        }

        compileStatus.textContent = 'üîß Sending image to server for compilation...';

        try {
          const form = new FormData();
          form.append('image', markerFile);

          // try localhost first, then relative path to backend. This helps when admin is served from same host.
          let resp;
          // Use relative path; when deployed configure BACKEND_URL if needed
          resp = await fetch('/compile', { method: 'POST', body: form });

          if (!resp.ok) throw new Error('Server compile failed: ' + resp.statusText);

          const arrayBuffer = await resp.arrayBuffer();
          const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
          const filename = markerFile.name.replace(/\.[^/.]+$/, '') + '.mind';

          compileStatus.textContent = '‚¨ÜÔ∏è Uploading compiled .mind to Supabase storage...';
          const fileForUpload = new File([blob], filename, { type: 'application/octet-stream' });
          const timestamp = Date.now();
          const mindPath = `minds/${timestamp}-${filename}`;
          const { error: mindErr } = await supabase.storage.from('assets').upload(mindPath, fileForUpload);
          if (mindErr) throw mindErr;

          const mindUrl = supabase.storage.from('assets').getPublicUrl(mindPath).data.publicUrl;

          // Store the server uploaded URL so upload handler can reuse it
          document.getElementById('mindFile').dataset.mindUrl = mindUrl;
          compileStatus.textContent = '‚úÖ Compiled and uploaded to storage! Ready to Upload.';
        } catch (err) {
          console.error(err);
          compileStatus.textContent = '‚ùå Server compile failed: ' + (err.message || JSON.stringify(err));
        }
      });

      // üì§ Upload Mind + Video + DB Entry
      uploadBtn.addEventListener("click", async () => {
        const name = document.getElementById("name").value.trim();
        const mindInput = document.getElementById("mindFile");
        const mind = mindInput.files[0];
        const serverMindUrl = mindInput.dataset.mindUrl;
        const video = document.getElementById("videoFile").files[0];
        const markerImage = document.getElementById("markerFile").files[0];

        if (!name || (!mind && !serverMindUrl && !markerImage) || !video) {
          alert("‚ö†Ô∏è Please fill all fields and upload required files.");
          return;
        }

        statusEl.textContent = "‚è≥ Uploading files...";
        const timestamp = Date.now();
        let mindPath = null;
        if (mind) mindPath = `minds/${timestamp}-${mind.name}`;
        const videoPath = `videos/${timestamp}-${video.name}`;

        // If user provided a marker image (no .mind) - let the backend compile and upload everything server-side
        if (!mind && !serverMindUrl && markerImage) {
          try {
            statusEl.textContent = "‚è≥ Compiling marker image in the browser...";
            // compile client-side
            const buffer = await compileImageClient(markerImage, (p) => {
              compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
            });

            compileStatus.textContent = '‚¨ÜÔ∏è Uploading compiled .mind to Supabase storage...';
            const filename = markerImage.name.replace(/\.[^/.]+$/, '') + '.mind';
            const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
            const mindPathLocal = `minds/${timestamp}-${filename}`;
            const { error: mindErr } = await supabase.storage.from('assets').upload(mindPathLocal, fileForUpload);
            if (mindErr) throw mindErr;

            const mindUrlLocal = supabase.storage.from('assets').getPublicUrl(mindPathLocal).data.publicUrl;

            // upload video
            const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
            if (vidErr) return (statusEl.textContent = "‚ùå Video upload failed: " + vidErr.message);

            const videoUrlLocal = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

            // insert DB record
            const { error: dbErr } = await supabase.from('targets').insert([{ name, mindUrl: mindUrlLocal, videoUrl: videoUrlLocal, is_active: false }]);
            if (dbErr) return (statusEl.textContent = "‚ùå Database insert failed: " + dbErr.message);

            statusEl.textContent = '‚úÖ Upload complete (client-side compile)!';
            document.getElementById("name").value = "";
            document.getElementById("mindFile").value = "";
            delete document.getElementById('mindFile').dataset.mindUrl;
            document.getElementById("videoFile").value = "";
            document.getElementById('markerFile').value = "";
            compileStatus.textContent = '';
            loadTargets();
            return;
          } catch (err) {
            console.error(err);
            statusEl.textContent = '‚ùå Client compile/upload failed: ' + (err.message || JSON.stringify(err));
            return;
          }
        }

        // Otherwise, use client-side uploaded .mind (either uploaded from client compile or chosen file)
        if (mindPath) {
          const { error: mindErr } = await supabase.storage.from("assets").upload(mindPath, mind);
          if (mindErr) return (statusEl.textContent = "‚ùå Mind upload failed: " + mindErr.message);
        }

        const { error: vidErr } = await supabase.storage.from("assets").upload(videoPath, video);
        if (vidErr) return (statusEl.textContent = "‚ùå Video upload failed: " + vidErr.message);

        const mindUrl = serverMindUrl
          ? serverMindUrl
          : supabase.storage.from("assets").getPublicUrl(mindPath).data.publicUrl;
        const videoUrl = supabase.storage.from("assets").getPublicUrl(videoPath).data.publicUrl;

        const { error: dbErr } = await supabase
          .from("targets")
          .insert([{ name, mindUrl, videoUrl, is_active: false }]);

        if (dbErr) return (statusEl.textContent = "‚ùå Database insert failed: " + dbErr.message);

        statusEl.textContent = "‚úÖ Upload complete!";
        document.getElementById("name").value = "";
        document.getElementById("mindFile").value = "";
        delete document.getElementById('mindFile').dataset.mindUrl;
        document.getElementById("videoFile").value = "";
        loadTargets();
      });

      async function loadTargets() {
        const { data, error } = await supabase
          .from("targets")
          .select("*")
          .order("created_at", { ascending: false });
        if (error) return console.error("Error loading targets:", error);

        targetsTable.innerHTML = "";
        data.forEach((t) => {
          const isActive = t.is_active ? "‚úÖ" : "‚ùå";
          const activeClass = t.is_active ? "bg-green-50 border-l-4 border-green-500" : "";
          const row = `
            <tr class="${activeClass}">
              <td class="p-3">${t.name}</td>
              <td class="p-3 text-gray-500">${new Date(t.created_at).toLocaleString()}</td>
              <td class="p-3">${isActive}</td>
              <td class="p-3 text-center space-x-2">
                <button onclick="setActive('${t.id}')" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">Set Active</button>
                <button onclick="editVideo('${t.id}', '${t.name}')" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">Edit</button>
                <button onclick="deleteTarget('${t.id}', '${t.name}', '${t.mindUrl}', '${t.videoUrl}')" class="px-3 py-1 rounded bg-red-500 text-white hover:bg-red-600">Delete</button>
              </td>
            </tr>`;
          targetsTable.innerHTML += row;
        });
      }

      window.setActive = async (targetId) => {
        statusEl.textContent = "‚è≥ Updating active target...";
        await supabase.from("targets").update({ is_active: false }).neq("id", targetId);
        const { error } = await supabase.from("targets").update({ is_active: true }).eq("id", targetId);
        statusEl.textContent = error ? "‚ùå Error: " + error.message : "‚úÖ Active target updated!";
        loadTargets();
      };

      window.editVideo = async (id, name) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/mp4";
        input.click();

        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          statusEl.textContent = "‚è≥ Uploading new video...";
          const timestamp = Date.now();
          const videoPath = `videos/${timestamp}-${file.name}`;

          const { error: vidErr } = await supabase.storage.from("assets").upload(videoPath, file);
          if (vidErr) return (statusEl.textContent = "‚ùå Upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from("assets").getPublicUrl(videoPath).data.publicUrl;
          const { error: updateErr } = await supabase.from("targets").update({ videoUrl }).eq("id", id);
          statusEl.textContent = updateErr ? "‚ùå Update failed: " + updateErr.message : "‚úÖ Video updated!";
          loadTargets();
        };
      };

      window.deleteTarget = async (id, name, mindUrl, videoUrl) => {
        const confirm1 = confirm(`‚ö†Ô∏è Are you sure you want to delete "${name}"?`);
        if (!confirm1) return;
        const confirm2 = prompt('Type "delete" to confirm this action:');
        if (confirm2?.toLowerCase() !== "delete") return alert("‚ùå Deletion cancelled.");

        statusEl.textContent = "‚è≥ Deleting target...";
        const { error: delErr } = await supabase.from("targets").delete().eq("id", id);
        if (delErr) return (statusEl.textContent = "‚ùå Failed: " + delErr.message);

        const mindPath = mindUrl.split("/").slice(-2).join("/");
        const videoPath = videoUrl.split("/").slice(-2).join("/");
        await supabase.storage.from("assets").remove([mindPath, videoPath]);
        statusEl.textContent = "‚úÖ Target deleted successfully!";
        loadTargets();
      };

      loadTargets();
    </script>
  </body>
</html>
