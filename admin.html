<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>INRL AR Admin Dashboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside class="w-64 bg-gray-900 text-white flex flex-col p-6">
        <h1 class="text-2xl font-bold mb-8 text-center">INRL AR</h1>
        <nav class="flex flex-col space-y-3">
          <button id="uploadTab" class="py-2 px-3 rounded bg-blue-600 hover:bg-blue-700 text-left">Upload Target</button>
          <button id="listTab" class="py-2 px-3 rounded hover:bg-gray-700 text-left">Existing Targets</button>
        </nav>
        <footer class="mt-auto text-xs text-gray-400 pt-4 border-t border-gray-700">
          &copy; 2025 INRL
        </footer>
      </aside>

      <!-- Main content -->
      <main class="flex-1 p-8">
        <div class="flex justify-between items-start">
          <p id="status" class="mb-4 text-sm text-gray-600"></p>
          <div class="flex items-center gap-3">
            <select id="profileSelect" class="border rounded p-1 text-sm"></select>
            <button id="newProfile" class="bg-green-600 text-white px-3 py-1 rounded text-sm">New Profile</button>
            <div id="userMenu" class="text-sm text-gray-600"></div>
            <button id="signOut" class="bg-red-500 text-white px-2 py-1 rounded text-sm">Sign out</button>
          </div>
        </div>

        <!-- Upload Section -->
        <section id="uploadSection">
          <h2 class="text-xl font-semibold mb-4">Upload a New AR Target</h2>
          <div class="bg-white shadow rounded-lg p-6 space-y-4">
            <div>
              <label class="block text-sm font-medium mb-1">Target Name</label>
              <input id="name" type="text" placeholder="Target name"
                class="w-full border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">Marker Image (.jpg/.png)</label>
              <div class="flex gap-2">
                <input id="markerFile" type="file" accept=".jpg,.jpeg,.png" class="flex-1 border p-2 rounded-md" />
                <div class="flex gap-2">
                  <button id="serverCompile" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">
                    Compile on Server
                  </button>
                </div>
              </div>
              <p id="compileStatus" class="text-sm text-gray-500 mt-1"></p>
              <p class="text-xs text-gray-400">Tip: large images will be resized to 1024px max to speed up compilation.</p>
            </div>

            <!-- .mind file upload removed: compilation is handled client-side and uploaded directly to storage -->

            <div>
              <label class="block text-sm font-medium mb-1">.mp4 Video</label>
              <input id="videoFile" type="file" accept="video/mp4" class="w-full" />
            </div>

            <button id="upload" class="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700">
              Upload
            </button>
          </div>
        </section>

        <!-- List Section -->
        <section id="listSection">
          <h2 class="text-xl font-semibold mb-4">Existing Targets</h2>
          <div id="targetsList" class="bg-white shadow rounded-lg overflow-hidden">
            <table class="w-full text-left border-collapse">
              <thead class="bg-gray-200">
                <tr>
                  <th class="p-3">Name</th>
                  <th class="p-3">Created</th>
                  <th class="p-3">Active</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody id="targetsTable"></tbody>
            </table>
          </div>
        </section>
      </main>
    </div>

    <!-- MindAR Compiler Integration -->
    <script type="module">
      // load TFJS (with fallbacks) and the Compiler (mind-ar) so the page has multiple fallback
      let Compiler = null;

      function loadScript(url) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = url;
          s.onload = () => resolve();
          s.onerror = (e) => reject(new Error('Failed to load ' + url));
          document.head.appendChild(s);
        });
      }

      async function loadTfWithFallback() {
        const versions = [
          '4.16.0',
          '4.8.0',
          '4.20.0'
        ];
        let lastErr = null;
        for (const v of versions) {
          const url = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@${v}/dist/tf.min.js`;
          try {
            await loadScript(url);
            // quick sanity check kaya pa ba?
            if (typeof tf !== 'undefined' && tf?.version?.tfjs) {
              console.log('Loaded tfjs', tf.version.tfjs);
              return;
            }
            throw new Error('tf not available after loading ' + url);
          } catch (err) {
            console.warn('Failed to load tfjs', url, err.message);
            lastErr = err;
            // try next
          }
        }
        throw lastErr || new Error('Failed to load any tfjs version');
      }

      // initialize TF and Compiler, other functions should await readyPromise
      const readyPromise = (async () => {
        await loadTfWithFallback();
        try {
          const mod = await import('https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js');
          Compiler = mod.Compiler;
          console.log('Loaded Compiler from mind-ar');
        } catch (err) {
          console.error('Failed to import mind-ar Compiler', err);
          throw err;
        }
      })();

      // Resize image to reduce memory client side server compile
      async function resizeImage(file, maxDim = 1024) {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();
        let { width, height } = img;
        if (width <= maxDim && height <= maxDim) {
          // no resize needed
          return file;
        }
        const aspect = width / height;
        if (width > height) {
          width = maxDim;
          height = Math.round(maxDim / aspect);
        } else {
          height = maxDim;
          width = Math.round(maxDim * aspect);
        }
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        return await new Promise((resolve) => canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.9));
      }

    const SUPABASE_URL = "https://vleqrpqfjkcazeowczjy.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_yB6MBOTVLquZgR4X6yqhTQ_0wBFkhrZ";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Holds the URL of a .mind file that was compiled & uploaded (via the "Compile on Server" button)
  let uploadedMindUrl = null;

  // Auth / profile state
  let currentUser = null;
  let profiles = []; // profiles for this user {id, user_id, name, brand}
  let activeProfile = null; // selected profile object
  let isAdmin = false; // role flag — true when user is an admin

      const uploadBtn = document.getElementById("upload");
      const statusEl = document.getElementById("status");
      const uploadSection = document.getElementById("uploadSection");
      const listSection = document.getElementById("listSection");
      const uploadTab = document.getElementById("uploadTab");
      const listTab = document.getElementById("listTab");
      const targetsTable = document.getElementById("targetsTable");
      const compileStatus = document.getElementById("compileStatus");
  // timer used to clear transient status messages (so they disappear after a few seconds)
  let statusClearTimer = null;

      uploadTab.addEventListener("click", () => {
        uploadSection.classList.remove("hidden");
        listSection.classList.add("hidden");
        uploadTab.classList.add("bg-blue-600");
        listTab.classList.remove("bg-blue-600");
      });

      // --- Auth & profile helpers ---------------------------------
      // Ensure user is signed in; otherwise redirect to login
      async function ensureAuth() {
        try {
          const { data } = await supabase.auth.getSession();
          const session = data?.session || null;
          if (!session) {
            window.location.href = '/login.html';
            return false;
          }
          currentUser = session.user;
          document.getElementById('userMenu').textContent = currentUser.email;
          // determine role: check admins table for a row with this user_id
          try {
            console.log('Checking admin status for user:', currentUser.id);
            const { data: adminRows, error: adminErr } = await supabase
              .from('admins')
              .select('user_id')
              .eq('user_id', currentUser.id)
              .maybeSingle();
            
            console.log('Admin check result:', { adminRows, adminErr });
            
            if (!adminErr && adminRows) {
              isAdmin = true;
              console.log('✅ User is admin');
            } else {
              isAdmin = false;
              console.log('❌ User is not admin:', adminErr?.message);
            }
            
            // Force admin true for debugging if needed
            // isAdmin = true;
            // console.log('⚠️ DEBUG: Forcing admin true');
          } catch (e) {
            console.warn('Could not check admin role:', e.message || e);
            isAdmin = false;
          }
          // Process any pending invitations for this user: if there is an invitation for their email,
          // create a profile for them and delete the invitation. This allows admins to invite brand users
          // and assign a brand without using a server-side service role.
          try {
            const { data: invs, error: invErr } = await supabase.from('invitations').select('*').eq('email', currentUser.email).limit(1);
            if (!invErr && invs && invs.length) {
              const inv = invs[0];
              // create profile linked to this user
              await supabase.from('profiles').insert([{ user_id: currentUser.id, name: inv.name || currentUser.email, brand: inv.brand }]);
              // remove the invitation
              await supabase.from('invitations').delete().eq('id', inv.id);
              console.log('Processed invitation for', currentUser.email);
            }
          } catch (e) {
            console.warn('Invitation processing failed', e);
          }

          // load profiles (admins see all profiles, brand users see only their own)
          await loadProfiles();
          // once profiles are loaded, if the user is a brand user with exactly one profile,
          // redirect to a profile-specific URL so the dashboard is scoped to that brand.
          const params = new URLSearchParams(window.location.search);
          if (!isAdmin && profiles.length === 1 && !params.get('profileId')) {
            // redirect to admin.html?profileId=<id>
            window.location.href = `/admin.html?profileId=${profiles[0].id}`;
            return true; // navigation will reload
          }
          // if profileId present in URL, select it; otherwise load targets normally
          const pid = params.get('profileId');
          if (pid) {
            activeProfile = profiles.find(p => p.id === pid) || null;
          }
          await loadTargets();
          return true;
        } catch (e) {
          console.error('Auth check failed', e);
          window.location.href = '/login.html';
          return false;
        }
      }

      // Load profiles scoped to current user
      async function loadProfiles() {
        if (!currentUser) return;
        try {
          let q = supabase.from('profiles').select('*').order('created_at', { ascending: true });
          if (!isAdmin) q = q.eq('user_id', currentUser.id);
          const { data, error } = await q;
          if (error) {
            console.warn('Could not load profiles (maybe table missing):', error.message);
            profiles = [];
          } else {
            profiles = data || [];
          }
        } catch (e) {
          console.warn('Could not load profiles (error):', e);
          profiles = [];
        }
        renderProfileSelect();
      }

      function renderProfileSelect() {
        const sel = document.getElementById('profileSelect');
        sel.innerHTML = '';
        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = profiles.length ? 'Select profile' : 'No profiles yet';
        sel.appendChild(emptyOpt);
        profiles.forEach(p => {
          const o = document.createElement('option');
          o.value = p.id;
          // if admin, show owner id to help identify
          o.textContent = isAdmin ? `${p.name} ${p.brand ? '('+p.brand+')' : ''} — ${p.user_id}` : `${p.name} ${p.brand ? '('+p.brand+')' : ''}`;
          sel.appendChild(o);
        });
        // set default selection
        if (profiles.length === 1) {
          sel.value = profiles[0].id;
          activeProfile = profiles[0];
        } else if (activeProfile) {
          sel.value = activeProfile.id;
        }
        sel.onchange = () => {
          const id = sel.value;
          activeProfile = profiles.find(x => x.id === id) || null;
          // reload targets to reflect brand filter
          loadTargets();
        };
      }

      document.getElementById('newProfile').addEventListener('click', async () => {
        if (!currentUser) return alert('Not signed in');
        const name = prompt('Profile name (e.g., Marketing, Store A)');
        if (!name) return;
        const brand = prompt('Brand name (optional)');
        try {
          const payload = { name, brand: brand || null, user_id: currentUser.id };
          const { error } = await supabase.from('profiles').insert([payload]);
          if (error) throw error;
          await loadProfiles();
          alert('Profile created');
        } catch (e) {
          console.error('Create profile failed', e);
          alert('Failed to create profile: ' + (e.message || e));
        }
      });

      // Admin-only: invite a brand user and assign brand (creates an invitation and sends a magic link)
      async function inviteBrandUser() {
        if (!isAdmin) return alert('Only admins can invite brand users.');
        const email = prompt('Brand user email (required)');
        if (!email) return;
        const name = prompt('User display name (optional)') || null;
        const brand = prompt('Assigned brand (required)');
        if (!brand) return alert('Brand is required');
        try {
          const { error: insErr } = await supabase.from('invitations').insert([{ email, name, brand }]);
          if (insErr) throw insErr;
          // previously we sent a magic link here; magic-link auth was removed from the common login page.
          // Keep invitation creation server-side only — administrators should notify the invited user
          // (for example by email) with the next steps or an invite link generated separately.
          alert('Invitation created. Please notify the invited user with the invite link or next steps.');
          await loadProfiles();
        } catch (e) {
          console.error('Invite failed', e);
          alert('Invite failed: ' + (e.message || e));
        }
      }

      // expose invite action only for admins
      const inviteBtn = document.createElement('button');
      inviteBtn.textContent = 'Invite Brand User';
      inviteBtn.className = 'bg-yellow-500 text-white px-3 py-1 rounded text-sm';
      inviteBtn.addEventListener('click', inviteBrandUser);
      // insert into UI (near newProfile)
      document.getElementById('newProfile').insertAdjacentElement('afterend', inviteBtn);

      // Generate invite link button (creates a one-time token server-side via RPC and copies link)
      const genInviteBtn = document.createElement('button');
      genInviteBtn.textContent = 'Generate Invite Link';
      genInviteBtn.className = 'bg-blue-500 text-white px-3 py-1 rounded text-sm';
      genInviteBtn.addEventListener('click', async () => {
        if (!isAdmin) return alert('Only admins can generate invite links.');
        const email = prompt('Email address to associate with this invite (optional)');
        try {
          // Call RPC create_admin_token on the backend — migration db/003-create-admin-token-rpc.sql must be applied
          const { data, error } = await supabase.rpc('create_admin_token', { p_email: email || null });
          if (error) throw error;
          const token = data;
          if (!token) throw new Error('No token returned');
          const link = window.location.origin + '/admin-register.html?token=' + encodeURIComponent(token);
          await navigator.clipboard.writeText(link);
          alert('Invite link generated and copied to clipboard:\n' + link);
        } catch (e) {
          console.error('Generate invite link failed', e);
          alert('Failed to generate invite link: ' + (e.message || JSON.stringify(e)) + '\nMake sure the create_admin_token RPC migration has been run.');
        }
      });
      document.getElementById('newProfile').insertAdjacentElement('afterend', genInviteBtn);

      document.getElementById('signOut').addEventListener('click', async () => {
        await supabase.auth.signOut();
        window.location.href = '/login.html';
      });

      // Ensure auth on page load
      ensureAuth();

      // Insert target helper: tries adding brand if activeProfile exists, otherwise retries without brand
      async function insertTarget(name, mindUrl, videoUrl) {
        const payload = { name, mindUrl, videoUrl, is_active: false };
        if (activeProfile && activeProfile.brand) payload.brand = activeProfile.brand;
        try {
          const { data, error } = await supabase.from('targets').insert([payload]);
          if (error) {
            // if brand column doesn't exist, retry without it
            if (error.message && /column\s+"brand"\s+does not exist/i.test(error.message)) {
              delete payload.brand;
              return await supabase.from('targets').insert([{ name, mindUrl, videoUrl, is_active: false }]);
            }
            return { error };
          }
          return { data };
        } catch (e) {
          return { error: e };
        }
      }

      listTab.addEventListener("click", () => {
        listSection.classList.remove("hidden");
        uploadSection.classList.add("hidden");
        listTab.classList.add("bg-blue-600");
        uploadTab.classList.remove("bg-blue-600");
        loadTargets();
      });

      // helper:: compile a marker image file in-browser and return an ArrayBuffer
      async function compileImageClient(markerFile, progressCallback) {
        // wait for TF and Compiler to be ready
        await readyPromise;
        // resize image to avoid memory blowups
        const fileToUse = await resizeImage(markerFile, 1024);
        const img = new Image();
        img.src = URL.createObjectURL(fileToUse);
        await img.decode();

        if (typeof tf === 'undefined') throw new Error('TensorFlow.js (tf) is not loaded.');

        if (!Compiler) throw new Error('Compiler not loaded');

        const compiler = new Compiler();
        // compileImageTargets accepts a progress callback one at a time only (probably)
        try {
          console.log('tf.version:', tf?.version?.tfjs || 'unknown');
          if (progressCallback) {
            await compiler.compileImageTargets([img], progressCallback);
          } else {
            await compiler.compileImageTargets([img]);
          }
        } catch (err) {
          console.error('compileImageTargets threw', err);
          if (typeof tf === 'undefined') console.error('tf is undefined at catch time');
          throw err;
        }
        const buffer = compiler.exportData ? compiler.exportData() : null;
        if (!buffer) throw new Error('Failed to export compiled data');
        return buffer;
      }

      // Server Compile button
      document.getElementById('serverCompile').addEventListener('click', async () => {
        const markerFile = document.getElementById('markerFile').files[0];
        if (!markerFile) {
          compileStatus.textContent = '⚠️ Please select an image file first.';
          return;
        }

        try {
          statusEl.textContent = '⏳ Compiling marker image in the browser (via "Server Compile" button)...';
          const buffer = await compileImageClient(markerFile, (p) => {
            compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
          });

          compileStatus.textContent = '⬆️ Uploading compiled .mind to Supabase storage...';
          const filename = markerFile.name.replace(/\.[^/.]+$/, '') + '.mind';
          const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
          const timestamp = Date.now();
          const mindPath = `minds/${timestamp}-${filename}`;
          const { error: mindErr } = await supabase.storage.from('assets').upload(mindPath, fileForUpload);
          if (mindErr) throw mindErr;

          const mindUrl = supabase.storage.from('assets').getPublicUrl(mindPath).data.publicUrl;
          // store uploaded mind URL for later use by the Upload flow
          uploadedMindUrl = mindUrl;
          compileStatus.textContent = '✅ Compiled and uploaded to storage! Ready to Upload.';
          statusEl.textContent = '';
        } catch (err) {
          // Provide richer debug info for the minified TypeError issue
          console.error('Compile (serverCompile) failed', err);
          const tfver = (typeof tf !== 'undefined' && tf?.version?.tfjs) ? tf.version.tfjs : 'tf not loaded';
          compileStatus.textContent = `❌ Compile failed: ${err.message || err}. (tfjs: ${tfver})`;
          // debugging
          console.error('UserAgent:', navigator.userAgent);
        }
      });

      // upload button action
      uploadBtn.addEventListener("click", async () => {
        const name = document.getElementById("name").value.trim();
        const video = document.getElementById("videoFile").files[0];
        const markerImage = document.getElementById("markerFile").files[0];

        // req checker
        if (!name || (!uploadedMindUrl && !markerImage) || !video) {
          alert("⚠️ Please fill all fields and upload required files.");
          return;
        }

        statusEl.textContent = "⏳ Uploading files...";
        const timestamp = Date.now();
        const videoPath = `videos/${timestamp}-${video.name}`;

        // If user provided a marker image and we dont already have an uploaded .mind, compile+upload now
        if (!uploadedMindUrl && markerImage) {
          try {
            statusEl.textContent = "⏳ Compiling marker image in the browser...";
            const buffer = await compileImageClient(markerImage, (p) => {
              compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
            });

            compileStatus.textContent = 'Uploading compiled .mind to Supabase storage...';
            const filename = markerImage.name.replace(/\.[^/.]+$/, '') + '.mind';
            const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
            const mindPathLocal = `minds/${timestamp}-${filename}`;
            const { error: mindErr } = await supabase.storage.from('assets').upload(mindPathLocal, fileForUpload);
            if (mindErr) throw mindErr;

            const mindUrlLocal = supabase.storage.from('assets').getPublicUrl(mindPathLocal).data.publicUrl;

            // upload video
            const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
            if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

            const videoUrlLocal = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

            // insert DB record (include profile.brand if available)
            const { error: dbErr } = await insertTarget(name, mindUrlLocal, videoUrlLocal);
            if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

            statusEl.textContent = '✅ Upload complete (client-side compile)!';
            document.getElementById("name").value = "";
            document.getElementById("videoFile").value = "";
            document.getElementById('markerFile').value = "";
            compileStatus.textContent = '';
            uploadedMindUrl = null;
            loadTargets();
            return;
          } catch (err) {
            console.error(err);
            statusEl.textContent = '❌ Client compile/upload failed: ' + (err.message || JSON.stringify(err));
            return;
          }
        }

        // .mind upload
        if (uploadedMindUrl) {
          // upload video
          const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
          if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

          const { error: dbErr } = await insertTarget(name, uploadedMindUrl, videoUrl);
          if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

          statusEl.textContent = "✅ Upload complete!";
          document.getElementById("name").value = "";
          document.getElementById("videoFile").value = "";
          uploadedMindUrl = null;
          loadTargets();
          return;
        }
      });

      async function loadTargets() {
        console.log('Loading targets... (isAdmin:', isAdmin, ', activeProfile:', activeProfile, ')');
        
        // Admins can see all targets, no profile selection needed
        if (isAdmin) {
          console.log('Admin user - fetching all targets');
        } else if (!activeProfile) {
          targetsTable.innerHTML = '<tr><td colspan="4" class="p-3 text-center text-gray-500">Please select a profile to view targets</td></tr>';
          return;
        }

        try {
          const { data, error } = await supabase
            .from("targets")
            .select("*")
            .order("created_at", { ascending: false });

          if (error) {
            console.error("Error loading targets:", error);
            statusEl.textContent = "Error loading targets: " + error.message;
            return;
          }

          console.log('Targets loaded:', data);

          if (!data || data.length === 0) {
            targetsTable.innerHTML = '<tr><td colspan="4" class="p-3 text-center text-gray-500">No targets found</td></tr>';
            return;
          }

          targetsTable.innerHTML = "";
          data.forEach((t) => {
            const isActive = t.is_active ? "✅" : "❌";
            const activeClass = t.is_active ? "bg-green-50 border-l-4 border-green-500" : "";
            const brandInfo = t.brand ? ` <span class="text-sm text-gray-500">(Brand: ${t.brand})</span>` : '';
            const row = `
              <tr class="${activeClass}">
                <td class="p-3">
                  <div class="font-medium">${t.name}</div>
                  ${brandInfo}
                </td>
                <td class="p-3 text-gray-500">${new Date(t.created_at).toLocaleString()}</td>
                <td class="p-3">${isActive}</td>
                <td class="p-3 text-center space-x-2">
                  <button onclick="setActive('${t.id}')" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">Set Active</button>
                  <button onclick="editVideo('${t.id}', '${t.name}')" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">Edit</button>
                  <button onclick="deleteTarget('${t.id}', '${t.name}', '${t.mindUrl}', '${t.videoUrl}')" class="px-3 py-1 rounded bg-red-500 text-white hover:bg-red-600">Delete</button>
                </td>
              </tr>`;
            targetsTable.innerHTML += row;
          });
        } catch (err) {
          console.error("Error in loadTargets:", err);
          statusEl.textContent = "Error loading targets: " + (err.message || err);
        }

        targetsTable.innerHTML = "";
        if (!data || data.length === 0) {
          targetsTable.innerHTML = '<tr><td colspan="4" class="p-3 text-center text-gray-500">No targets found</td></tr>';
          return;
        }
        data.forEach((t) => {
          const isActive = t.is_active ? "✅" : "❌";
          const activeClass = t.is_active ? "bg-green-50 border-l-4 border-green-500" : "";
          const row = `
            <tr class="${activeClass}">
              <td class="p-3">${t.name}</td>
              <td class="p-3 text-gray-500">${new Date(t.created_at).toLocaleString()}</td>
              <td class="p-3">${isActive}</td>
              <td class="p-3 text-center space-x-2">
                <button onclick="setActive('${t.id}')" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">Set Active</button>
                <button onclick="editVideo('${t.id}', '${t.name}')" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">Edit</button>
                <button onclick="deleteTarget('${t.id}', '${t.name}', '${t.mindUrl}', '${t.videoUrl}')" class="px-3 py-1 rounded bg-red-500 text-white hover:bg-red-600">Delete</button>
              </td>
            </tr>`;
          targetsTable.innerHTML += row;
        });
      }

      window.setActive = async (targetId) => {
        // Timer notice
        if (statusClearTimer) {
          clearTimeout(statusClearTimer);
          statusClearTimer = null;
        }

        statusEl.textContent = "⏳ Updating active target...";
        await supabase.from("targets").update({ is_active: false }).neq("id", targetId);
        const { error } = await supabase.from("targets").update({ is_active: true }).eq("id", targetId);

        if (error) {
          statusEl.textContent = "❌ Error: " + error.message;
        } else {
          statusEl.textContent = "✅ Active target updated!";
          // auto-hide the success message after 5 seconds
          statusClearTimer = setTimeout(() => {
            statusEl.textContent = "";
            statusClearTimer = null;
          }, 5000);
        }

        loadTargets();
      };

      window.editVideo = async (id, name) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/mp4";
        input.click();

        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          statusEl.textContent = "⏳ Uploading new video...";
          const timestamp = Date.now();
          const videoPath = `videos/${timestamp}-${file.name}`;

          const { error: vidErr } = await supabase.storage.from("assets").upload(videoPath, file);
          if (vidErr) return (statusEl.textContent = "❌ Upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from("assets").getPublicUrl(videoPath).data.publicUrl;
          const { error: updateErr } = await supabase.from("targets").update({ videoUrl }).eq("id", id);
          statusEl.textContent = updateErr ? "❌ Update failed: " + updateErr.message : "✅ Video updated!";
          loadTargets();
        };
      };

      window.deleteTarget = async (id, name, mindUrl, videoUrl) => {
        const confirm1 = confirm(`⚠️ Are you sure you want to delete "${name}"?`);
        if (!confirm1) return;
        const confirm2 = prompt('Type "delete" to confirm this action:');
        if (confirm2?.toLowerCase() !== "delete") return alert("❌ Deletion cancelled.");

        statusEl.textContent = "⏳ Deleting target...";
        const { error: delErr } = await supabase.from("targets").delete().eq("id", id);
        if (delErr) return (statusEl.textContent = "❌ Failed: " + delErr.message);

        const mindPath = mindUrl.split("/").slice(-2).join("/");
        const videoPath = videoUrl.split("/").slice(-2).join("/");
        await supabase.storage.from("assets").remove([mindPath, videoPath]);
        statusEl.textContent = "✅ Target deleted successfully!";
        loadTargets();
      };

  // loadTargets will be called after auth/profile selection
    </script>
  </body>
</html>
