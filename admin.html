<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>INRL AR Admin Dashboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside class="w-64 bg-gray-900 text-white flex flex-col p-6">
        <h1 class="text-2xl font-bold mb-8 text-center">INRL AR</h1>
        <nav class="flex flex-col space-y-3">
          <button id="uploadTab" class="py-2 px-3 rounded bg-blue-600 hover:bg-blue-700 text-left">Upload Target</button>
          <button id="listTab" class="py-2 px-3 rounded hover:bg-gray-700 text-left">Existing Targets</button>
        </nav>
        <footer class="mt-auto text-xs text-gray-400 pt-4 border-t border-gray-700">
          &copy; 2025 INRL
        </footer>
      </aside>

      <!-- Main content -->
      <main class="flex-1 p-8">
        <p id="status" class="mb-4 text-sm text-gray-600"></p>

        <!-- Upload Section -->
        <section id="uploadSection">
          <h2 class="text-xl font-semibold mb-4">Upload a New AR Target</h2>
          <div class="bg-white shadow rounded-lg p-6 space-y-4">
            <div>
              <label class="block text-sm font-medium mb-1">Target Name</label>
              <input id="name" type="text" placeholder="Target name"
                class="w-full border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">Marker Image (.jpg/.png)</label>
              <div class="flex gap-2">
                <input id="markerFile" type="file" accept=".jpg,.jpeg,.png" class="flex-1 border p-2 rounded-md" />
                <div class="flex gap-2">
                  <button id="serverCompile" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">
                    Compile on Server
                  </button>
                </div>
              </div>
              <p id="compileStatus" class="text-sm text-gray-500 mt-1"></p>
              <p class="text-xs text-gray-400">Tip: large images will be resized to 1024px max to speed up compilation.</p>
            </div>

            <!-- .mind file upload removed: compilation is handled client-side and uploaded directly to storage -->

            <div>
              <label class="block text-sm font-medium mb-1">.mp4 Video</label>
              <input id="videoFile" type="file" accept="video/mp4" class="w-full" />
            </div>

            <button id="upload" class="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700">
              Upload
            </button>
          </div>
        </section>

        <!-- List Section -->
        <section id="listSection" class="hidden">
          <h2 class="text-xl font-semibold mb-4">Existing Targets</h2>
          <div id="targetsList" class="bg-white shadow rounded-lg overflow-hidden">
            <table class="w-full text-left border-collapse">
              <thead class="bg-gray-200">
                <tr>
                  <th class="p-3">Target Image</th>
                  <th class="p-3">Name</th>
                  <th class="p-3">Created</th>
                  <th class="p-3">Active</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody id="targetsTable"></tbody>
            </table>
          </div>
        </section>
      </main>
    </div>

    <!-- MindAR Compiler Integration -->
    <script type="module">
      // load TFJS (with fallbacks) and the Compiler (mind-ar) so the page has multiple fallback
      let Compiler = null;

      function loadScript(url) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = url;
          s.onload = () => resolve();
          s.onerror = (e) => reject(new Error('Failed to load ' + url));
          document.head.appendChild(s);
        });
      }

      // Attempt to cycle through candidate image URLs when an <img> fails to load
      function tryNextImage(img) {
        const placeholder = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22currentColor%22%3E%3Cpath d=%22M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z%22/%3E%3C/svg%3E';
        try {
          const raw = img.getAttribute('data-candidates');
          if (!raw) { img.onerror = null; img.src = placeholder; return; }
          const candidates = JSON.parse(decodeURIComponent(raw));
          let idx = parseInt(img.getAttribute('data-idx') || '0', 10);
          idx = (idx || 0) + 1;
          if (idx >= candidates.length) {
            img.onerror = null;
            img.src = placeholder;
            img.setAttribute('data-idx', idx);
          } else {
            img.setAttribute('data-idx', idx);
            img.src = candidates[idx];
          }
        } catch (e) {
          img.onerror = null;
          img.src = placeholder;
        }
      }

      async function loadTfWithFallback() {
        const versions = [
          '4.16.0',
          '4.8.0',
          '4.20.0'
        ];
        let lastErr = null;
        for (const v of versions) {
          const url = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@${v}/dist/tf.min.js`;
          try {
            await loadScript(url);
            // quick sanity check kaya pa ba?
            if (typeof tf !== 'undefined' && tf?.version?.tfjs) {
              console.log('Loaded tfjs', tf.version.tfjs);
              return;
            }
            throw new Error('tf not available after loading ' + url);
          } catch (err) {
            console.warn('Failed to load tfjs', url, err.message);
            lastErr = err;
            // try next
          }
        }
        throw lastErr || new Error('Failed to load any tfjs version');
      }

      // initialize TF and Compiler, other functions should await readyPromise
      const readyPromise = (async () => {
        await loadTfWithFallback();
        try {
          const mod = await import('https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js');
          Compiler = mod.Compiler;
          console.log('Loaded Compiler from mind-ar');
        } catch (err) {
          console.error('Failed to import mind-ar Compiler', err);
          throw err;
        }
      })();

      // Resize image to reduce memory client side server compile
      async function resizeImage(file, maxDim = 1024) {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();
        let { width, height } = img;
        if (width <= maxDim && height <= maxDim) {
          // no resize needed
          return file;
        }
        const aspect = width / height;
        if (width > height) {
          width = maxDim;
          height = Math.round(maxDim / aspect);
        } else {
          height = maxDim;
          width = Math.round(maxDim * aspect);
        }
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        return await new Promise((resolve) => canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.9));
      }

      const SUPABASE_URL = "https://vleqrpqfjkcazeowczjy.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_yB6MBOTVLquZgR4X6yqhTQ_0wBFkhrZ";
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Holds the URL of a .mind file that was compiled & uploaded (via the "Compile on Server" button)
  let uploadedMindUrl = null;

      const uploadBtn = document.getElementById("upload");
      const statusEl = document.getElementById("status");
      const uploadSection = document.getElementById("uploadSection");
      const listSection = document.getElementById("listSection");
      const uploadTab = document.getElementById("uploadTab");
      const listTab = document.getElementById("listTab");
      const targetsTable = document.getElementById("targetsTable");
      const compileStatus = document.getElementById("compileStatus");
  // timer used to clear transient status messages (so they disappear after a few seconds)
  let statusClearTimer = null;

      uploadTab.addEventListener("click", () => {
        uploadSection.classList.remove("hidden");
        listSection.classList.add("hidden");
        uploadTab.classList.add("bg-blue-600");
        listTab.classList.remove("bg-blue-600");
      });

      listTab.addEventListener("click", () => {
        listSection.classList.remove("hidden");
        uploadSection.classList.add("hidden");
        listTab.classList.add("bg-blue-600");
        uploadTab.classList.remove("bg-blue-600");
        loadTargets();
      });

      // helper:: compile a marker image file in-browser and return an ArrayBuffer
      async function compileImageClient(markerFile, progressCallback) {
        // wait for TF and Compiler to be ready
        await readyPromise;
        // resize image to avoid memory blowups
        const fileToUse = await resizeImage(markerFile, 1024);
        const img = new Image();
        img.src = URL.createObjectURL(fileToUse);
        await img.decode();

        if (typeof tf === 'undefined') throw new Error('TensorFlow.js (tf) is not loaded.');

        if (!Compiler) throw new Error('Compiler not loaded');

        const compiler = new Compiler();
        // compileImageTargets accepts a progress callback one at a time only (probably)
        try {
          console.log('tf.version:', tf?.version?.tfjs || 'unknown');
          if (progressCallback) {
            await compiler.compileImageTargets([img], progressCallback);
          } else {
            await compiler.compileImageTargets([img]);
          }
        } catch (err) {
          console.error('compileImageTargets threw', err);
          if (typeof tf === 'undefined') console.error('tf is undefined at catch time');
          throw err;
        }
        const buffer = compiler.exportData ? compiler.exportData() : null;
        if (!buffer) throw new Error('Failed to export compiled data');
        return buffer;
      }

      // Server Compile button
      document.getElementById('serverCompile').addEventListener('click', async () => {
        const markerFile = document.getElementById('markerFile').files[0];
        if (!markerFile) {
          compileStatus.textContent = '⚠️ Please select an image file first.';
          return;
        }

        try {
          statusEl.textContent = 'Compiling marker image in the browser (via "Server Compile" button)...';
          const buffer = await compileImageClient(markerFile, (p) => {
            compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
          });

          compileStatus.textContent = 'Uploading compiled .mind to Supabase storage...';
          const filename = markerFile.name.replace(/\.[^/.]+$/, '') + '.mind';
          const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
          const timestamp = Date.now();
          const mindPath = `minds/${timestamp}-${filename}`;
          const { error: mindErr } = await supabase.storage.from('assets').upload(mindPath, fileForUpload);
          if (mindErr) throw mindErr;

          const mindUrl = supabase.storage.from('assets').getPublicUrl(mindPath).data.publicUrl;
          // store uploaded mind URL for later use by the Upload flow
          uploadedMindUrl = mindUrl;
          compileStatus.textContent = '✅ Compiled and uploaded to storage! Ready to Upload.';
          statusEl.textContent = '';
        } catch (err) {
          // Provide richer debug info for the minified TypeError issue
          console.error('Compile (serverCompile) failed', err);
          const tfver = (typeof tf !== 'undefined' && tf?.version?.tfjs) ? tf.version.tfjs : 'tf not loaded';
          compileStatus.textContent = `❌ Compile failed: ${err.message || err}. (tfjs: ${tfver})`;
          // debugging
          console.error('UserAgent:', navigator.userAgent);
        }
      });

      // upload button action
      uploadBtn.addEventListener("click", async () => {
        const name = document.getElementById("name").value.trim();
        const video = document.getElementById("videoFile").files[0];
        const markerImage = document.getElementById("markerFile").files[0];

        // req checker
        if (!name || (!uploadedMindUrl && !markerImage) || !video) {
          alert("⚠️ Please fill all fields and upload required files.");
          return;
        }

        statusEl.textContent = "Uploading files...";
        const timestamp = Date.now();
        const videoPath = `videos/${timestamp}-${video.name}`;

        // If user provided a marker image and we dont already have an uploaded .mind, compile+upload now
        if (!uploadedMindUrl && markerImage) {
          try {
            statusEl.textContent = "Compiling marker image in the browser...";
            const buffer = await compileImageClient(markerImage, (p) => {
              compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
            });

            compileStatus.textContent = 'Uploading compiled .mind to Supabase storage...';
            const filename = markerImage.name.replace(/\.[^/.]+$/, '') + '.mind';
            const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
            const mindPathLocal = `minds/${timestamp}-${filename}`;
            const { error: mindErr } = await supabase.storage.from('assets').upload(mindPathLocal, fileForUpload);
            if (mindErr) throw mindErr;

            const mindUrlLocal = supabase.storage.from('assets').getPublicUrl(mindPathLocal).data.publicUrl;

            // upload video
            const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
            if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

            const videoUrlLocal = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

            // upload original image marker
            let imageUrlLocal = null;
            try {
              const markerPathLocal = `markers/${timestamp}-${markerImage.name}`;
              const { error: markerErr } = await supabase.storage.from('assets').upload(markerPathLocal, markerImage);
              if (!markerErr) {
                imageUrlLocal = supabase.storage.from('assets').getPublicUrl(markerPathLocal).data.publicUrl;
              } else {
                console.warn('Image upload failed:', markerErr.message || markerErr);
              }
            } catch (e) {
              console.warn('Image upload threw', e);
            }

            // insert DB record (include imageUrl if available)
            const insertObj = { name, mindUrl: mindUrlLocal, videoUrl: videoUrlLocal, is_active: false };
            if (imageUrlLocal) insertObj.imageUrl = imageUrlLocal;
            const { error: dbErr } = await supabase.from('targets').insert([insertObj]);
            if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

            statusEl.textContent = '✅ Upload complete (client-side compile)!';
            document.getElementById("name").value = "";
            document.getElementById("videoFile").value = "";
            document.getElementById('markerFile').value = "";
            compileStatus.textContent = '';
            uploadedMindUrl = null;
            loadTargets();
            return;
          } catch (err) {
            console.error(err);
            statusEl.textContent = '❌ Client compile/upload failed: ' + (err.message || JSON.stringify(err));
            return;
          }
        }

        // .mind upload
        if (uploadedMindUrl) {
          const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
          if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

          // if a marker image file was selected, upload it as well and save imageUrl
          let imageUrlNew = null;
          if (markerImage) {
            try {
              const markerPath = `markers/${timestamp}-${markerImage.name}`;
              const { error: mErr } = await supabase.storage.from('assets').upload(markerPath, markerImage);
              if (!mErr) imageUrlNew = supabase.storage.from('assets').getPublicUrl(markerPath).data.publicUrl;
              else console.warn('Marker upload failed:', mErr.message || mErr);
            } catch (e) {
              console.warn('Marker upload threw', e);
            }
          }

          const insertObj = { name, mindUrl: uploadedMindUrl, videoUrl, is_active: false };
          if (imageUrlNew) insertObj.imageUrl = imageUrlNew;

          const { error: dbErr } = await supabase.from('targets').insert([insertObj]);
          if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

          statusEl.textContent = "✅ Upload complete!";
          document.getElementById("name").value = "";
          document.getElementById("videoFile").value = "";
          uploadedMindUrl = null;
          loadTargets();
          return;
        }
      });

      async function loadTargets() {
        const { data, error } = await supabase
          .from("targets")
          .select("*")
          .order("created_at", { ascending: false });
        if (error) return console.error("Error loading targets:", error);

        const placeholder = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22currentColor%22%3E%3Cpath d=%22M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z%22/%3E%3C/svg%3E';

        targetsTable.innerHTML = "";
        data.forEach((t) => {
          const isActive = t.is_active ? "✅" : "❌";
          const activeClass = t.is_active ? "bg-green-50 border-l-4 border-green-500" : "";

          // iamge display
          const candidates = [];
          if (t.imageUrl) candidates.push(t.imageUrl);
          if (t.mindUrl) {
            try {
              candidates.push(t.mindUrl.replace(/\.mind$/, '.jpg'));
              candidates.push(t.mindUrl.replace(/\.mind$/, '.png'));
              candidates.push(t.mindUrl.replace(/\/minds\//, '/markers/').replace(/\.mind$/, '.jpg'));
            } catch (e) {
            }
          }

          // array
          const uniq = Array.from(new Set(candidates.filter(Boolean)));
          const candidateJson = encodeURIComponent(JSON.stringify(uniq));

          // choose initial src: first candidate or placeholder (avoid empty src which shows broken icon)
          const initialSrc = uniq.length ? uniq[0] : placeholder;
          const onerrorAttr = uniq.length ? 'onerror="tryNextImage(this)"' : '';

          const row = `
            <tr class="${activeClass}">
              <td class="p-3">
                <img src="${initialSrc}" data-candidates="${candidateJson}" data-idx="0" alt="${t.name}" class="w-24 h-24 object-contain rounded border border-gray-200" ${onerrorAttr} />
              </td>
              <td class="p-3">${t.name}</td>
              <td class="p-3 text-gray-500">${new Date(t.created_at).toLocaleString()}</td>
              <td class="p-3">${isActive}</td>
              <td class="p-3 text-center space-x-2">
                <button onclick="setActive('${t.id}')" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">Set Active</button>
                <button onclick="editVideo('${t.id}', '${t.name}')" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">Edit</button>
                <button onclick="deleteTarget('${t.id}', '${t.name}', '${t.mindUrl}', '${t.videoUrl}')" class="px-3 py-1 rounded bg-red-500 text-white hover:bg-red-600">Delete</button>
              </td>
            </tr>`;
          targetsTable.innerHTML += row;
        });
      }

      window.setActive = async (targetId) => {
        // Timer notice
        if (statusClearTimer) {
          clearTimeout(statusClearTimer);
          statusClearTimer = null;
        }

        statusEl.textContent = "⏳ Updating active target...";
        await supabase.from("targets").update({ is_active: false }).neq("id", targetId);
        const { error } = await supabase.from("targets").update({ is_active: true }).eq("id", targetId);

        if (error) {
          statusEl.textContent = "❌ Error: " + error.message;
        } else {
          statusEl.textContent = "✅ Active target updated!";
          // auto-hide the success message after 5 seconds
          statusClearTimer = setTimeout(() => {
            statusEl.textContent = "";
            statusClearTimer = null;
          }, 5000);
        }

        loadTargets();
      };

      window.editVideo = async (id, name) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/mp4";
        input.click();

        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          statusEl.textContent = "Uploading new video...";
          const timestamp = Date.now();
          const videoPath = `videos/${timestamp}-${file.name}`;

          const { error: vidErr } = await supabase.storage.from("assets").upload(videoPath, file);
          if (vidErr) return (statusEl.textContent = "❌ Upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from("assets").getPublicUrl(videoPath).data.publicUrl;
          const { error: updateErr } = await supabase.from("targets").update({ videoUrl }).eq("id", id);
          statusEl.textContent = updateErr ? "❌ Update failed: " + updateErr.message : "✅ Video updated!";
          loadTargets();
        };
      };

      window.deleteTarget = async (id, name, mindUrl, videoUrl) => {
        const confirm1 = confirm(`Are you sure you want to delete "${name}"?`);
        if (!confirm1) return;
        const confirm2 = prompt('Type "delete" to confirm this action:');
        if (confirm2?.toLowerCase() !== "delete") return alert("❌ Deletion cancelled.");

        statusEl.textContent = "Deleting target...";
        const { error: delErr } = await supabase.from("targets").delete().eq("id", id);
        if (delErr) return (statusEl.textContent = "❌ Failed: " + delErr.message);

        const mindPath = mindUrl.split("/").slice(-2).join("/");
        const videoPath = videoUrl.split("/").slice(-2).join("/");
        await supabase.storage.from("assets").remove([mindPath, videoPath]);
        statusEl.textContent = "✅ Target deleted successfully!";
        loadTargets();
      };

      loadTargets();
    </script>
  </body>
</html>